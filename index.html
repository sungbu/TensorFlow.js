<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1.快速上手</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
    <!-- 图标库 -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>
</head>
<body>
    <script>
        //创建模型
        function createModel() {
            //创建一个顺序模型
            const model = tf.sequential();

            //创建一个密集层
            model.add(tf.layers.dense({
                units: 1, //节点数量
                useBias: true, //是否使用偏置
                activation: "linear", //使用线性激活函数
                inputDim: 1
            }));

            return model;
        }


        //画图表
        async function plot(pointArray,featureName) {
            tfvis.render.scatterplot(
                //图表名字
                {name: `${featureName} vs House Price`},
                //数据和数据类型名
                {values:[pointArray], series:["original"]},
                //x，y轴名称
                {
                    xLabel: featureName,
                    yLabel: "Price"
                }
            )
        }

        //讲数值归并到0-1区间
        //公式 x = x - min(x) / max(x) - min(x)
        function normalise(tensor) {
            const min = tensor.min();
            const max = tensor.max();

            const normalisedTensor = tensor.sub(min).div(max.sub(min));

            return {
                tensor: normalisedTensor,
                min,
                max
            };
        }

        async function run () {
            //加载csv数据集文件
            const houseScalesDataset = tf.data.csv("http://127.0.0.1:5500/kc_house_data.csv");

            //为图表做准备 x轴为sqft_living  y轴为price
            const pointsDataset = houseScalesDataset.map(record => ({
                x: record.sqft_living,
                y: record.price
            }))
            const points = await pointsDataset.toArray();

            //方便拆分数组 如果数组长度为奇数 85行会报错
            if(points.length % 2 !== 0){
                points.pop();
            }

            //洗牌
            tf.util.shuffle(points);

            plot(points,"Square Feet")


            //创建两个张量Tensor

            //提取一个特征  Feature（inputs）
            const featureValues = points.map(p => p.x);
            const featureTensor = tf.tensor2d(featureValues,[featureValues.length, 1]);

            //提取一个标签   lable（outputs）
            const lableValues = points.map(p => p.y);
            const lableTensor = tf.tensor2d(lableValues,[lableValues.length, 1]);


            //数据归一化 0-1区间
            const normalisedFeature = normalise(featureTensor);
            const normalisedLable = normalise(lableTensor);

            normalisedFeature.tensor.print();
            normalisedLable.tensor.print();

            //将数组按 50% 50% 的比例拆除成两个数组
            const [trainingFeatureTensor,testingFeatureTensor] = tf.split(normalisedFeature.tensor,2);
            const [trainingLableTensor,testingLableTensor] = tf.split(normalisedLable.tensor,2);

            trainingFeatureTensor.print(true);

            const model = createModel();

        }
        run();
    </script>
</body>
</html>